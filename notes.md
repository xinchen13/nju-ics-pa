# PA0
### 安装Linux与相关工具
### 获取框架代码: [NJU ICS PA](https://github.com/NJU-ProjectN/ics-pa.git): `2022`作为默认分支
### 配置git, 并修改`/Makefile`中的ID与name, 以及开发追踪`git commit`的author 
### 尝试配置、编译并运行nemu

# PA1
### 初始化 `am-kernels`
### 在配置文件中选择ISA为riscv32
### 修复`welcome()`函数导致的错误
根据log输出注释`welcome()`函数中的`assert(0)`语句

### 修复运行NEMU之后直接键入`q`退出产生的报错
根据gdb单步执行结果, 发现`engine_start()`函数结束后返回`is_exit_status_bad()`，此函数定义在`nemu/src/utils/state.c`根据其要求，发现返回值为`-1`. 查看代码，他是利用`nemu_state`来判定返回值. 其中判断语句为:

```c
int good = (nemu_state.state == NEMU_END && nemu_state.halt_ret == 0) || (nemu_state.state == NEMU_QUIT);
```

因此，只需要将按下`q`时的`nemu_state.state`设置为`NEMU_QUIT`即可，这样就可正常退出程序. 由于NEMU中`c`和`q`分别对应`nemu/src/monitor/sdb/sdb.c`中的`cmd_c()`与`cmd_q()`函数，发现`cmd_c()`函数调用了`cpu_exec()`, 此函数中对`nemu_state`作出了修改. 同理，我们可以直接在`cmd_q()`中添加代码改变`nemu_state`的值, 之后重新编译运行，测试无误

### 单步执行
框架代码中已经给出了模拟CPU执行方式的函数, 即在`nemu/src/cpu/cpu-exec.c`中的`cpu_exec(uint64_t n)`, 基于此，单步执行要求执行N条指令后暂停执行，换句话说就是从命令行读取到N ，就将`cpu_exec()`函数执行N次

首先在`cmd_table`中添加`si`命令，然后编写`cmd_si(char *args)`函数完成功能. 从命令行读取命令并获得参数，`cmd_help()`函数中给出了例子，直接按其的框架修改. 利用`strtok()`函数获取参数，缺省时默认为1; 给`cpu_exec()`传入参数n(即执行的指令条数即可)

`sscanf`通常被用来解析并转换字符串，其格式定义灵活多变，可以实现很强大的字符串解析功能: 在这里从字符串读入格式化内容，并解析为`int`类型数字, `strtok()`可以每次提取一个词条(提取参数)

### 打印寄存器
要求执行`info r`之后, 就调用`nemu/src/isa/$ISA/reg.c`目录下的`isa_reg_display()`, 在里面直接通过`printf()`输出所有寄存器的值即可. RTFSC可知，寄存器结构体`CPU_state`的定义放在`nemu/src/isa/$ISA/include/isa-def.h`中, 并在`nemu/src/cpu/cpu-exec.c`中定义一个全局变量`cpu`

首先在`cmd_table`中添加`info`命令, 并设置参数`r`. 之后就在`cmd_info(char *args)`函数中利用`strcmp()`进行参数判断与调用`isa_reg_display()`

在`isa_reg_display()`中通过`printf()`格式控制输出`pc`和32个通用寄存器的值，由于ISA为`riscv32`, 因此通用寄存器可以32位表示, 采用api提供的`FMT_WORD`来输出

### 扫描内存
对命令进行解析之后, 先求出表达式的值(还没有实现表达式求值的功能, 可以先实现一个简单的版本: 规定表达式`EXPR`中只能是一个十六进制数), 解析出待扫描内存的起始地址之后, 就可以使用循环将指定长度的内存数据通过十六进制打印出来

与之前类似的做法依次提取参数，并通过`sscanf()`函数来把读取的字符串转化为整形，第一个参数是开始的地址，第二个参数是读取的4字节数; 读取内存利用`vaddr_read(vaddr_t addr, int len)`函数按字节读取(需要增加头文件`#include <memory/vaddr.h>`)

### 表达式求值: 算术表达式的词法分析
为算术表达式中的各种token类型添加规则，在成功识别出token后, 将token的信息依次记录到`tokens`数组中

词法分析识别出表达式中的token，包含很多复杂场景，如: 十六进制整数`0x80100000`, 小括号, 访问寄存器`$a0`, 指针解引用`*`, 访问变量`number`等. 可以用正则表达式来匹配复杂pattern

在框架代码中, 一条规则是由正则表达式和token类型组成的二元组. 框架代码中已经给出了`+`和空格串的规则, 其中空格串的token类型是`TK_NOTYPE`, 因为空格串并不参加求值过程, 识别出来之后就可以将它们丢弃了; `+`的token类型是`+`. 事实上token类型只是一个整数, 只要保证不同的类型的token被编码成不同的整数就可以了

这些规则会在简易调试器初始化的时候通过`init_regex()`被编译成一些用于进行pattern匹配的内部信息, 这些内部信息是被库函数使用的, 而且它们会被反复使用, 但你不必关心它们如何组织. 但如果正则表达式的编译不通过, NEMU将会触发assertion fail, 此时需要检查编写的规则是否符合正则表达式的语法

给出一个待求值表达式, 我们首先要识别出其中的token, 进行这项工作的是`make_token()`函数. `make_token()`函数的工作方式十分直接, 它用`position`变量来指示当前处理到的位置, 并且按顺序尝试用不同的规则来匹配当前位置的字符串. 当一条规则匹配成功, 并且匹配出的子串正好是`position`所在位置的时候, 我们就成功地识别出一个token, `Log()`宏会输出识别成功的信息. 需要做的是将识别出的token信息记录下来(一个例外是空格串), 我们使用`Token`结构体来记录token的信息

其中`type`成员用于记录token的类型. 大部分token只要记录类型就可以了, 例如`+`, `-`, `*`, `/`, 但这对于有些token类型是不够的: 如果我们只记录了一个十进制整数token的类型, 在进行求值的时候我们还是不知道这个十进制整数是多少. 这时我们应该将token相应的子串也记录下来, `str`成员就是用来做这件事情的. 由于`str`成员的长度是有限的, 在存储对应的`str`字段时进行长度判断，防止缓冲区溢出. `tokens`数组用于按顺序存放已经被识别出的token信息, `nr_token`指示已经被识别出的token数目

如果尝试了所有的规则都无法在当前位置识别出token, 识别将会失败, 框架代码会输出当前token的位置(当表达式过长导致在终端里输出需要换行时, `^`可能无法指示正确的位置, 此时通过输出的`position`值来定位token的位置). 这通常是待求值表达式并不合法造成的,`make_token()`函数将返回`false`, 表示词法分析失败

接下来在`expr.c`文件中`rules[]`完善算术表达式规则(添加了十进制数字、`+`,`-`,`*`,`/`,`(`,`)`运算符和空格); 并为`make_token()`函数添加对应的操作，通过switch语句把识别到的token保存到`tokens[]`数组中，添加debug语句, 至此就完成了算术表达式的词法分析

除此以外，还在`expr.c`中添加了宏`TOKEN_STR_LEN_MAX`以及`TOKENS_COUNT_MAX`来控制记录的token字符串最大长度与表达式最大长度. 还添加了调试宏`TOKENS_DEBUG`来控制词法分析中间过程的结果输出

### 表达式求值: 递归求值
既然长表达式是由短表达式构成的, 就先对短表达式求值, 然后再对长表达式求值. 这种十分自然的解决方案就是分治法的应用, 可以使用递归实现

一个问题是, 给出一个最左边和最右边不同时是括号的长表达式, 我们要怎么正确地将它分裂成两个子表达式? 我们定义"主运算符"为表达式人工求值时, 最后一步进行运行的运算符, 它指示了表达式的类型(例如当一个表达式的最后一步是减法运算时, 它本质上是一个减法表达式). 要正确地对一个长表达式进行分裂, 就是要找到它的主运算符. 如何在一个token表达式中寻找主运算符:

1. 非运算符的token不是主运算符
2. 出现在一对括号中的token不是主运算符. 注意到这里不会出现有括号包围整个表达式的情况, 因为这种情况已经在`check_parentheses()`相应的if块中被处理了
3. 主运算符的优先级在表达式中是最低的. 这是因为主运算符是最后一步才进行的运算符, `priority()`是设计用于判断运算同一层符优先级的函数
4. 当有多个运算符的优先级都是最低时, 根据结合性, 最后被结合的运算符才是主运算符. 一个例子是 `1 + 2 + 3`, 它的主运算符应该是右边的`+`
5. 要找出主运算符, 只需要将token表达式全部扫描一遍, 就可以按照上述方法唯一确定主运算符

找到了正确的主运算符之后, 先对分裂出来的两个子表达式进行递归求值, 然后再根据主运算符的类型对两个子表达式的值进行运算即可.

需要注意的是, 上述框架中并没有进行错误处理, 在求值过程中发现表达式不合法的时候, 应该给上层函数返回一个表示出错的标识, 告诉上层函数"求值的结果是无效的". 例如在`check_parentheses()`函数中, `(4 + 3)) * ((2 - 1)`和`(4 + 3) * (2 - 1)`这两个表达式虽然都返回false, 因为前一种情况是表达式不合法, 是没有办法成功进行求值的; 而后一种情况是一个合法的表达式, 是可以成功求值的, 只不过它的形式不属于BNF中的`(" <expr> ")`, 需要使用主运算符的方式进行处理, 因此在`check_parentheses()`作出区分, 并且层层传递的`success`变量作为求值是否成功的标识符

最后在`eval()`函数中根据BNF框架实现递归求值; 

### 表达式求值: 区分减号和负号(乘号和指针解引用)
在上述实现中, 并没有考虑负数的问题, 例如`1+-1`和`--1`(我们不实现自减运算, 这里应该解释成`-(-1)=1`)
它们会被判定为不合法的表达式. 为了实现负数的功能, 需要考虑两个问题:

#### 如何区分负号和减号:
`-`符号判定为负号分为以下几种情况:
1. 处于表达式头部
2. 处于`(`后
3. 处于`+`, `-`, `*`, `/`, 负号, 逻辑判断符号后

#### 负号是个单目运算符, 分裂的时候需要注意什么:
1. 负号运算同解指针一样，具有最高的运算优先级
2. 主要根据表达式前一词条的类型来分离负号与减号
3. 在`eval()`函数中设定负号的运算方式为`0-val2`
4. 规定在选定主运算符时，最先出现的负号为主运算符(右结合性)

### 表达式求值: 实现表达式生成器
表达式生成器的框架代码在`nemu/tools/gen-expr/gen-expr.c`中. 需要实现其中的`void gen_rand_expr()`函数, 将随机生成的表达式输出到缓冲区buf中. main函数中的代码会调用你实现的`gen_rand_expr()`, 然后把buf中的随机表达式放入上述C程序的代码中. 剩下的事情就是编译运行这个C程序了, 代码中使用了`system()`和`popen()`等库函数来实现这一功能. 最后, 框架代码将这个C程序的打印结果和之前随机生成的表达式一同输出, 这样就生成了一组测试用例, 在实现过程中，需要面对一些细节的问题:

#### 如何生成随机数
`uint32_t choose(uint32_t n)`是一个很简单又很重要的函数, 它的作用是生成一个小于n的随机数, 所有随机生成的内容几乎都是通过它来选择的，通过设置seed来确保一定的随机性

#### 如何保证表达式进行无符号运算
在`gen-expr`进行表达式运算的字符串中，把数字的格式改为如`66u`与`-32u`的格式，存储为无符号类型，就能够进行无符号运算

#### 如何随机插入空格
通过`gen_rand_blank()`函数在表达式中随机插入0-2个空格

#### 如何生成长表达式, 同时不会使buf溢出
首先控制生成数字的大小为0-99; 其次通过为表达式生成函数`gen_rand_expr()`传递生成次数，并对其生成次数进行限制，就能够有效限制长表达式长度; 与此同时，修改`expr.c`中tokens数组的大小为1024，以容纳更长的表达式

#### 如何过滤求值过程中有除0行为的表达式
注意到发生除零操作时gcc会给出`waring: division by zero`，因此在编译表达式计算器的时候为gcc加入选项`-Werror`来改变除零时的返回值，从而抛弃该条表达式(同时对于结果溢出的表达式也会一同抛弃)

P.S.:每次生成新的表达式需要对buf进行清零操作，具体为`buf[0] = '\0';`, 否则表达式会向后拼接产生问题

实现后, 就可以用来生成表达式求值的测试用例了. 通过`./gen-expr 10000 > input`生成10000个(由于剔除了除零的表达式，实际数量在9000+个)测试用例到input文件中, 其中每行为一个测试用例, 其格式为`结果 表达式`

再稍微改造一下nemu的`main()`函数, 让其读入`input`文件中的测试表达式后, 直接调用`expr()`, 并与正确结果进行比较. 为了容纳长表达式的求值, 还需要对tokens数组的大小进行修改，实际上对`sdb_mainloop()`函数进行了修改:

- 在`Kconfig`中添加宏`DEBUG_EXPR`作为开关来设置debug模式，选择性编译
- 若比较结果通过则输出`PASS`,否则中断程序(`assert(0)`)

通过`make run > tools/gen-expr/build/result`输出结果到`result`文件

### 表达式求值: 功能扩展
之前已经实现了算术表达式的求值, 但这些表达式都是由常数组成的, 它们的值不会发生变化. 这样的表达式在监视点中没有任何意义, 为了发挥监视点的功能, 首先需要扩展表达式求值的功能: 主要包括增加对十六进制数, 寄存器, ==, !=, &&和指针解引用的支持

关于获取寄存器的值, 这是一个ISA相关的功能. 框架代码已经准备`isa_reg_str2val(const char *s, bool *success)`API(用于返回名字为s的寄存器的值, 并设置success指示是否成功), 在部署过程中，需要将保存的寄存器字符串与pc、32个通用寄存器名对比，输出对应寄存器的值

还需要注意的是指针解引用(dereference)的识别, 在进行词法分析的时候, 我们其实没有办法把乘法和指针解引用区别开来, 因为它们都是`*`. 在进行递归求值之前, 我们需要将它们区别开来, 否则如果将指针解引用当成乘法来处理的话, 求值过程将会认为表达式不合法. 其实要区别它们也不难, 给你一个表达式, 你也能将它们区别开来. 实际上, 我们只要看`*`前一个token的类型, 我们就可以决定这个*是乘法还是指针解引用了(与负号的判断方法类似)

另外和GDB中的表达式相比, 我们做了简化, 简易调试器中的表达式没有类型之分, 因此需要额外说明两点:

- 所有结果都是`uint32_t`类型
- 指针也没有类型, 进行指针解引用的时候, 我们总是从客户计算机的内存中读出一个`uint32_t`类型的整数

综上，需要修改的地方主要有:
- 用于匹配的正则表达式
- 数据/符号类型
- 识别到表达式后存储到tokens数组
- 数据需要在`eval()`函数中得到值
- 符号需要规定运算
- 符号涉及运算优先级
- 需要注意单目运算符的右结合性(在选定主运算符的时候)

### 监视点
简易调试器允许用户同时设置多个监视点, 删除监视点, 因此我们最好使用链表将监视点的信息组织起来. 框架代码中已经定义好了监视点的结构体(在`nemu/src/monitor/sdb/watchpoint.c`中)

但结构体中只定义了两个成员: `NO`表示监视点的序号, `next`指向下一个监视点. 为了实现监视点的功能, 需要根据对监视点工作原理的理解在结构体中增加必要的成员. 同时我们使用"池"的数据结构来管理监视点结构体, 框架代码中已经给出了一部分相关的代码: 代码中定义了监视点结构的池`wp_pool`, 还有两个链表`head`和`free_`, 其中`head`用于组织使用中的监视点结构, `free_`用于组织空闲的监视点结构, `init_wp_pool()`函数会对两个链表进行初始化

为了使用监视点池, 需要编写以下两个函数(可以根据需要修改函数的参数和返回值): `WP* new_wp()`和`void free_wp(WP *wp)`

其中`new_wp()`从`free_`链表中返回一个空闲的监视点结构, `free_wp()`将`wp`归还到`free_`链表中, 这两个函数会作为监视点池的接口被其它函数调用. 需要注意的是, 调用`new_wp()`时可能会出现没有空闲监视点结构的情况, 为了简单起见, 此时可以通过`assert(0)`马上终止程序. 框架代码中定义了32个监视点结构, 一般情况下应该足够使用, 如果你需要更多的监视点结构, 你可以修改`NR_WP`宏的值

- 为了保存需要监视的表达式，给`WP`类型新增了`WP_expr`字符串
- 注意到在同一程序运行过程中监视点编号是不断增加的
- `free_wp`用于释放监视点，在gdb中是依据监视点编号来工作的，这里保持一致

当用户给出一个待监视表达式时, 需要通过`new_wp()`申请一个空闲的监视点结构, 并将表达式记录下来. 然后在`trace_and_difftest()`函数(在`nemu/src/cpu/cpu-exec.c`中定义)的最后扫描所有的监视点, 每当`cpu_exec()`的循环执行完一条指令, 都会调用一次`trace_and_difftest()`函数. 在扫描监视点的过程中, 需要对监视点的相应表达式进行求值(之前已经实现表达式求值的功能了), 并比较它们的值有没有发生变化, 若发生了变化, 程序就因触发了监视点而暂停下来, 需要将`nemu_state.state`变量设置为`NEMU_STOP`来达到暂停的效果. 最后输出一句话提示用户触发了监视点, 并返回`sdb_mainloop()`循环中等待用户的命令

- 在本部分的实现中，首先为监视点新增一个成员`val`来保存相应的监视点的值，用于比较新旧值
- 选择在`trace_and_difftest()`中调用`check_watchpoint()`, 计算新的监视表达式的值并对比
- 若存在多个表达式的值发生变化, 则全部打印完后再暂停程序
- 设置`NEMU_STOP`时需要判断程序是否运行结束，若运行结束则不改变`nemu_state.state`
- 把watchpoint相关的变量与函数声明移到`sdb.h`中，方便`cpu-exec.c`调用

由于监视点的功能需要在`cpu_exec()`的每次循环中都进行检查, 这会对nemu的性能带来较为明显的开销. 我们可以把监视点的检查放在`trace_and_difftest()`中, 并用一个新的宏`CONFIG_WATCHPOINT`把检查监视点的代码包起来; 然后在`nemu/Kconfig`中的"Testing and Debugging"目录为监视点添加一个开关选项, 最后通过`menuconfig`打开这个选项, 从而激活监视点的功能. 当你不需要使用监视点时, 可以在`menuconfig`中关闭这个开关选项来提高nemu的性能

最后，使用'w'命令来申请监视点; 使用`info w`命令来打印使用中的监视点信息, 至于要打印什么, 可以参考GDB中`info watchpoints`的运行结果, 在这里选择打印监视点的序号和监视表达式; 使用`d`命令来删除监视点, 只需要释放相应的监视点结构即可, 通过序号调用`free_wp()`删除监视点

# PA2

# PA3

# PA4